# 10 密码学协议动物园

1. 本节学习密码学协议。这些协议以之前学习的密码学知识为基础实现了一些“奇妙”的事情！
2. 动物园地图
   - 密码学协议种类繁多，应用广泛。
3. 目录：略
4. 协议：
   - **通信协议**是为了一个特定目的的数字消息格式与交换规则的形式化描述
     - 协议之于通信，如算法之于计算
     - 每个人必须知道并同意服从协议
   - 无歧义：每个步骤必须被明确定义且无误解的可能
   - 完备性：对每个可能的情况都必须有一个明确的行为
   - 密码学协议：除了上述属性，还应该不可能比协议中说明的做的更多或者知道的更多
5. 协议类型
   - 仲裁协议：一个仲裁者是一个公正的可信第三方，帮助完成协议
   - 审判协议：一个法官是也是一个公正的可信第三方。与仲裁者不同，其不直接参与协议，而是来审判协议是否正确执行
   - 自强制协议：最佳的协议类型。协议本身保证公平性。
   - 例子：两人平分蛋糕协议。先分蛋糕的人后选。
6. 对协议的攻击
   - 被动攻击：攻击者不影响协议，例如窃听
   - 主动攻击：攻击者更改协议以获得优势
   - 作弊者：攻击者是协议中的一方
     - 被动作弊者：按照协议执行，但试图获得比协议所设定的更多的信息
     - 主动作弊者：在协议进程中干扰协议来作弊
7. 三次传递协议
   - 目的：两方之间无共享密钥下的保密通信
   - 类比：两人同一个箱子来传递一个秘密，该箱子可以上锁
     - 第一步，Alice将秘密放进箱子里，并上一把只有Alice自己有钥匙的锁，发送给Bob
     - 第二步，Bob收到箱子后，也无法打开箱子；在箱子上又上一把只有Bob自己能打开的锁，并发送给Alice
     - 第三步，Alice收到箱子后，打开自己之前上的锁，并发送给Bob；Bob收到箱子后打开自己上的锁，得到秘密
   - 这个方案需要加密方案具有一个性质：$\mathsf{Dec}_{k_1}(\mathsf{Enc}_{k_2}(\mathsf{Enc}_{k_1}(m))) = \mathsf{Enc}_{k_2}(m)$；用两个密钥分别加密两次后，用任意一个密钥解密，得到另一个密钥加密的密文
   - Shamir协议：$p$ 是一个素数，生成 $e,d$ 满足$\gcd(e,p-1)=1$ 并且 $ed \equiv 1 \pmod{p-1}$；加密$c = m^e$，满足上面的性质。
   - 弱点：中间人攻击，也叫水桶小队攻击。
     - Alice并不能确定和其通信的真的是Bob本人，Bob也不能确定对方是Alice。中间人攻击可以伪装成双方，与双方分别进行三次传递协议，与双方分别传递一个秘密，而双方并不知情。中间人可以获得Alice发给Bob的秘密，也可以伪造一个秘密发给Bob。
8. 中间人攻击
   - 在一个新场景，通信双方交换彼此公钥并传递密文，也存在一种中间人攻击。攻击者与受害双方分别独立建立连接，并且在双方之间中继消息，使得双方以为在和彼此通信。
   - 敌手在中间用自己的密钥来执行协议，交换后的明文没有变化，而Alice和Bob都无法发现他们实际上是在于攻击者通信。
9. 互锁协议
   - 介绍一种抵御上面的中间人攻击的方法，并不需要对双方身份进行鉴别。
   - 这是由Ron Rivest和Adi Shamir提出的，思路是将两个要交换的密文分成两部分，分别先交换密文的一半，然后再交换另一半。
   - 敌手收到一半密文后，因为没有得到整个密文，无法用自己的密钥解密的原本的明文，无法传递密文的一半。如果敌手自己产生一个明文，加密并发送，那么就无法最终令诚实方收到原本的消息。与其他身份鉴别方案结合，可以发现攻击者。
10. 双线性映射
    - 三个循环群之间存在一个关系，称为双线性映射（也叫双线性配对）：两个群中两个元素的对可以被有效映射到第三个群中的元素。前两个群是同一个群，其中的两个元素$aP$和$bP$可以被有效映射到第三个群中的元素$P^{ab}$。由此，得到$G_1$中一对元素$aP$和$bP$与另一对元素$P$和$abP$将映射到$G_2$中的同一个元素。
    - 定理：若映射是有效的，则在$G_1$中的判断式DH问题，即给定$aP$和$bP$，判定一个元素是否是$abP$，就是一个容易的问题，因为可以判断一对元素$(P,cP)$是否映射到$e(P,P)^{ab}$。
    - Weil和Tate配对是两个常用的双线性映射，其中$G_1$是椭圆曲线群，$G_2$是有限域。
11. Jounx密钥交换协议
    - Jounx的一轮、三方密钥协商协议，其中Alice计算密钥$e(bP, cP)^a = e(P, P)^{abc}$；
    - 双线性DH（BDH）假设：给定$\left<P, aP, bP, cP \right>$，计算$e(P, P)^{abc}$是难题；
    - 定理：给定BDH假设，Jounx协议是安全的。
12. 基于身份的加密
    - IBE：不使用数字证书来实现公钥分发，直接用接收方的ID作为公钥，例如，直接用接收方的email地址作为其公钥。需要一个可信第三方来协助，即密钥生成中心KGC；
    - 接收方从KGC获得自己私钥；发送方需要预先获得KGC的公钥，但不再需要接收方的数字证书。
    - 优点：TTP在生成用户的私钥后可以被去掉，不需要PKI来分发密钥
    - 弱点：单点失效，隐式的密钥托管
13. Boneh-Franklin的IBE方案
    - 由Boneh和Franklin两人在2001年提出的IBE方案。
    - KGC负责产生一个全局公钥$sP$和私钥$s$，并为用户$A$生成一个私钥$d_{A} = sH_1(A)$
      - 用户私钥由KGC私钥和其身份得到
    - 加密：$\mathsf{Enc}(sP, A, m) = \left< rP, m\oplus H_2(e(H_1(A), sP)^r)\right>$，$c = (u, v)$
      - 用户公钥由KGC公钥和其身份得到
    - 解密：接收方从KGC获得其私钥$d_{A} = sH_1(A)$，并解密$\mathsf{Dec}(d_{A}, u, v) = v \oplus H_2(e(d_A, u)).$ 
      - 根据私钥无法获知$s$，因为这是一个离散对数问题
    - 正确性：$e(d_A, u) = e(sH_1(A), rP) = e(H_1(A), P)^{sr} = e(H_1(A), sP)^r$
14. 盲签名
    - 签名者在看不见消息的情况下对消息签名；
    - 类比隔着一个信封对一个文件盖一个钢印，然后打开信封，文件上有钢印；
    - Chaum的盲签名方案：
      - Alice将消息加密后发给签名者，类比于将文件装进了信封；
      - 签名者对密文签名，类比于隔着信封盖钢印；
      - Alice将加密消息的签名处理后得到原消息的签名，发送给Bob，类比于打开信封，发送带钢印的文件。
15. 群签名
    - 群签名是一种签名方案，一组人中某一个人的签名可以被公开验证是这组人中的某一个人签的，但不能确认到底是谁签的。这组人中有一个组长，他可以确认并证明是谁签的。
      - 有效性：群成员的签名可被验证有效；
      - 不可伪造：只有群成员可以进行有效签名；
      - 匿名性：不知道具体是谁签的；
      - 可追踪：群主可以知道是谁签的；
      - 不可关联：不能判断两个签名是否是同一个人签的；
      - 可开脱：不能伪造其他成员的签名，可以证明不是自己签的；
    - 一个简单的群签名方案：组长负责生成所有公私钥对，并发给每个组员一对。使用一个未被使用过的私钥来签名，并用所有公钥来验证。这个方案满足以上性质。
16. 环签名
    - 环签名是一种特殊的群签名，但其中不需要组长，并且无法确认到底是谁签的。
    - 基于双线性映射可以实现环签名。签名者用其他人的公钥和自己的私钥来签名，验证时需要使用所有人的公钥。
17. 秘密分享
    - 一个秘密在一组人中共享，每个人持有秘密的一部分，但当手里的秘密的份数没有达到某个阈值的时候，没有人能还原秘密；而当秘密的份数达到了某个阈值时，可以还原出秘密。
    - 例子，一个三维空间中的一个点，可以被分解为三个面；
    - 例子，中国剩余定理中将秘密分解为各个素数的群中元素；
18. Shamir的秘密分享
    - 利用一个线性多项式来分享秘密。秘密是该多项式中常数项，每一份秘密是该多项式的一个点。一个$t$次多项式，至少需要$t+1$个点来确定常数项，即秘密。
    - 例子，将一个2次多项式中的秘密分成6份，至少用3份可以恢复秘密。敌手如果有两个小秘密（两个点），但至少有3个未知数，包括$a_1$、$a_2$和$m_1 - m_2$，因此无法求解出任何未知数。
    - 优点：实现了信息论的安全
    - 缺点：每份秘密的正确性无法验证
19. 门限密码学
    - 在一个(t, n)门限加密方案中，需要至少n个参与方中的t个小秘密才可以解密密文或签名消息。
    - 利用Elgamal加密方案可以实现一个门限加密方案。采用Shamir的秘密分享方案令私钥 $s = \Sigma_i s_i\cdot \lambda_i$ ，其中$s_i = f(i)$是小秘密；$\lambda_i$ 是拉格朗日系数，是公开信息；并且公开发布 $h_i = g^{s_i}$ 。
      - 其中，公开$h_i$是用于后面验证秘密持有者持有小秘密$s_i$，即一个离散对数问题的解，并且用这个小秘密来对密文进行解密；
    - 加密：按照普通的Elgamal加密方案加密$(c_1, c_2) = (g^y, h^y \cdot m)$，$y$为新的随机数；
    - 解密：秘密持有者 $i$用自己的小秘密来解密，输出 $d_i = c_1^{s_i}$ 和一个关于 $\log_gh_i = \log_{c_1} d_i$ 的零知识证明（后面会介绍）；
      - 这里秘密持有者利用自己的小秘密来实现解密，但不泄漏小秘密；同时，证明自己是秘密持有者；
    - 解密出消息 $ m = c_2/\Pi_i d_i^{\lambda_i} $，因为$c_2/\Pi_i d_i^{\lambda_i} = c_2/\Pi_i c_1^{s_i\cdot \lambda_i} = c_2/c_1^{\Sigma_i s_i\cdot \lambda_i} = c_2/c_1^s=m$。
20. 承诺方案
    - 互联网上掷硬币：利用哈希函数实现对承诺的绑定（binding），即信息和承诺一一对应，承诺后不能改变信息；和隐藏（hiding），即承诺本身不泄漏信息；
    - 掷硬币并对结果做出承诺：随机选择一个比特$b$为掷硬币结果，将$h = \mathsf{Hash}(b\|r)$作为承诺发送给对方；其中，$r$为随机串；这个承诺具有绑定和隐藏的功能；
    - 收到承诺的一方给出自己猜测的结果；此时，仍不知道实际结果，但条件是哈希函数需要隐藏信息；
    - 掷硬币一方揭示结果，由于抗碰撞性质，只能揭示$b\| r$，否则会被对方利用收到的承诺来识破；
21. 零知识证明
    - 一种交互式证明，其中证明方成功说服验证方：证明方知道某事，但同时除了该陈述外，不泄漏任何其他信息
    - 完备性：如果陈述是真的，那么诚实的验证方可以被诚实的证明方说服
    - 有效性：如果陈述是假的，那么没有作弊的证明方可以说服诚实的验证方
    - 存在性：如果单项函数存在，则存在对任意NP问题的零知识证明
    - 西格玛协议：分三轮：声明（承诺），挑战，响应
22. 一个玩具例子
    - 有一个环形山洞，山洞有一个入口，从A和B两条路可以进入洞内；在内部有一个魔法门，魔法门可以用一个咒语开启
    - Alice知道开启魔法门的咒语，并想向Bob证明，步骤分三步：
    - 声明（承诺）：Alice随机选择一条路进入山洞内部并藏起来，Bob不知道Alice的选择；Bob站在洞口
    - 挑战：Bob向洞内大喊：“请从A/B方向出来”
    - 响应：根据Bob的挑战和Alice当时进入山洞的选择，Alice可以利用咒语开启魔法门，或者直接从洞中出来
    - 以上游戏重复多次，如果Alice的次次都通过挑战，那么Bob可以相信Alice知道咒语
    - 为什么这是零知识证明？
      - 表面的原因：这个游戏中对Bob有意义的唯一知识——魔法门咒语，Bob始终不知道
      - 更本质的原因：知道魔法门咒语和读心术（Alice预知验证者Bob给出挑战）之间不可区分
23. 汉弥尔顿环路的零知识证明
    - 汉弥尔顿环路是一个NPC问题：给定一个图，给出一个经过所有节点一次的环路。证明者知道一个图的汉弥尔顿环路；
    - 声明（承诺）：首先，证明者将图重新做标记：将节点重新编号，并构造邻接矩阵（行列表示节点，两点之间有连接时置1，否则置0）；将原节点编号和新编号对应关系（N个箱子，N为图中节点数量）以及新邻接矩阵（N*(N-1)/2个箱子）加密，全部发送给验证者
    - 挑战：验证者从两个挑战问题中随机选择一个，一是打开被加密消息中所有箱子，以揭示其与原图是同一个图；二是打开被加密的邻接矩阵中一个汉弥尔顿环路，但不打开原节点编号和新编号对应关系的箱子
      - 第一个挑战可以令验证者确认证明者的确对图做重新标记
      - 第二个挑战可以令验证者确认证明者的确知道一个环路，但泄漏给验证者答案
    - 响应：证明者根据挑战，或者揭示所有箱子，或者揭示一个汉弥尔顿环路
    - 零知识：知道汉弥尔顿环路和预知挑战问题之间不可区分
24. 零知识证明和承诺
    - 模拟范式：当一件事Y本来就可以从X得到，那么通过Y并不会从X额外获得什么；这个范式用于保证验证者不会通过证明过程额外知道其他知识；
    - 在关于是否知道RSA私钥的零知识证明中，验证者给一个密文C后，让证明者给出对应明文M，来验证证明者知道私钥
      - 当没有承诺协议时，验证者可能在不知道明文M时直接给出一个密文C，而证明者返回的消息M令验证者额外知道了M；
      - 当加入承诺后时，证明者在给出M之前，先给出对M的承诺，即不泄漏M，又对后面给出的M作出承诺；在验证者提供M后，证明者知道验证者已经知道M了，根据上面的模拟范式可知，之后验证者获得的M对于验证者也不是新信息。
25. Schnorr协议
    - 之前在数字签名中学习过的Schnorr身份认证协议就是一个对离散对数问题的零知识证明
    - 知道离散对数的解和预知挑战之间不可区分
26. 破解RSA能力的零知识证明
    - 知道RSA问题的解和操纵挑战c之间不可区分
27. 健忘传输
    - 健忘传输：发送者不知道信息是否被传递
    - 社会学家百万富翁问题：判断两个数（各自的工资）是否相同，但不暴露工资（如果两人相同，则知道对方工资）
    - **1**  Bob准备4个有锁的建议箱（上面有投递口）并标记上工资数额
    - **2**  Bob销毁所有建议箱的钥匙，除了那个标记为他自己工资的箱子的钥匙
    - **3**  Alice将“YES”的纸条放进标记为她自己工资的箱子中，将“NO”的纸条放进其他箱子中
    - **4**  Bob打开标记他自己工资的箱子，可以（也可以不）将纸条与Alice分享
    - 健忘传输：Alice一共发送了4个消息，但不知道Bob得到其中哪一个消息
28. Rabin的健忘传输协议
    - Alice向Bob发送消息，但不知道Bob是否可以解密并获得该消息
    - 1 Alice将消息$m$用RSA加密后发送给Bob，内容为$N, e, m^e \mod N$
    - 2 Bob将一个随机的二次剩余发送给Alice，内容为$x^2 \mod N$
    - 3 Alice求$x^2$的平方根$y$，这是本身是一个难题；由于Alice可以分解$N$，所以可计算出来，并将$y$发送给Bob
    - 4 如果$y \neq ± x$，Bob可以计算出$m$，即得到消息
    - 这个方案的原理在于，当$y \neq ± x$时，$y^2 - x^2 = 0$且$(y-x)$或$(y+x)$中有$N$的因子，Bob可以利用$\gcd(y-x,N)$将$N$分解，并计算出解密密钥$d$；由于每个二次剩余有四个根，因此，Bob有1/2的机会分解$N$并得到消息；但是，Alice并不知道$y \neq ± x$是否成立，也就不清楚Bob是否能得到消息
29. 二选一健忘传输
    - 二选一健忘传输：发送者发送了两个消息，知道接收者收到了两个消息中的一个，但不知道具体是哪一个；接收者只能随机地收到两个消息中的一个
    - 1 Alice将公钥和两个随机数发送给Bob，内容为$N, e, x_0, x_1$
    - 2 Bob随机生成一个比特$b$和一个随机数$k$，计算$v = x_b + k^e$并发送给Alice
    - 3 Alice尝试计算$k$，$k_0 = (v - x_0)^d$，$k_1 = (v-x_1)^d$，其中有一个是$k$，但Alice不知道是哪个；接着，将消息$m_0$和$m_1$分别用$k_0$和$k_1$加密得到$k_0 + m_0$和$k_1 + m_1$，发送给Bob
    - 4 Bob用$k$从中解密出一个消息$m_b$
30. 安全多方计算
    - 一群人用大家的输入共同计算一个函数，但保留各自输入的隐私
    - 密码学家午餐问题：一群密码学家在饭后判断是否有人买单，但不知道每个人是否买单；至多有一个人买单，如果买单，则输入为1，否则为0，这是一个布尔或的多方安全计算问题
    - 密码学家围坐在一个圆桌，相邻的人共同协商一个比特的秘密
    - 每个密码学家喊出一个消息：三个比特的异或值，包括自己是否买单的一个比特，和相邻的人协商的两个比特
      - 这一步使得每个密码学家是否买单是保密的，相邻的人也无法推测出来
    - 最后，每个人将所有密码学家喊出的消息异或，就得到了一个布尔或；如果结果为1，则说明有人买单；否则，还没有人买单；
      - 这是因为相邻的人协商的秘密都出现了2次，异或为0；每个人自己是否买单的比特都出了1次，当至多有一个1时，其“异或”结果与“或”的结果相同
31. 同态加密
    - 两个密文操作后，得到新密文；新密文解密后得到对应两个明文操作后的结果，即$\mathsf{Dec}_{sk}(c_1\circ c_2)=m_1\circ m_2$.
    - Elgamal加密方案是乘法的同态加密方案
    - Pailier加密方案是加法的同态加密方案
    - 应用：投票，计票，但不暴露投票内容
    - 第一个支持加法和乘法的完全同台加密方案在2009年由Craig Gentry提出
32. 端到端投票系统
    - 端到端投票系统
      - 投票：投票到投票机
      - 张贴：将票公开到公告烂
      - 计票：根据公告栏由选举官计票

    - 安全目标
      - 端到端可验证性：任何投票者确信按意愿投票，按投票来张贴，按张贴来计票
      - 隐私：没人知道投了什么票，甚至投票者也无法说服其他人她投了什么票；隐私意味着抗强迫！
33. 三票投票法
    - 原理：按行选，按列投
    - 每个投票者投三张票，每行是一个候选人，每列是一张票。每行做1或2个标记，选谁就做2个标记，不选谁就做1个标记。不能不做，也不能做3个标记。
    - 每张票有唯一的ID。所有票公布在PBB上。
    - 投票者将任意一张票的拷贝作为收据带回家。收据用对照PBB做完整性检查。
    - 是否是安全的端到端投票？
34. 量子密码学
    - 利用量子物理学规律的密码学
    - 量子物理学规律：超态，相干，纠缠，不可测
35. 量子密码学现状
    - 并未证明量子计算机比经典图灵机强
    - 有多项式时间的算法用量子计算机解决难问题：整数分解，离散对数
    - 一些问题还没有多项式时间量子算法，例如NPC问题，一些单项函数求逆，对称加密和MAC
36. 量子密钥分发
    - BB84 QKD，由**Bennett和Brassard (1984)**发明，利用光子偏振状态来在公开信道上传递消息，并可以发现窃听者
    - 利用光子偏振的方向来表达信息，分为+和x两种基（Basis），其中
      - +: 竖线表示0，横线表示1
      - x:撇表示0，捺表示1
      - 用与制备基相同的测量基来测量，则得到原始光子偏振方向；否则，得到随机的方向
    - 首先，Alice产生随机比特串，并用随机生成的一组制备基来产生相应的带偏振的光子，发送给Bob
    - 然后，Bob产生随机测量基来测量光子偏振，得到一个比特串
    - 最后，Alice和Bob公开自己的制备基和测量基，将使用了相同基处理和得到的部分比特串作为密钥的一部分；为了检查是否有人窃听，也就是在传递信道中对光子偏振测量；Alice和Bob分配公开一段相同基下得到的比特串，如果相同说明中间没有人窃听；如果敌手窃听，则会影响量子传输过程，光子被其他的基测量后会改变偏振方向，从而被监测发现
37. 总结：克拉克三定律之一：任何足够先进的技术和魔法是不可区分的。



